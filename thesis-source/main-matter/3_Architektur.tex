Die hier zu entwickelnde Anwendung dient zum Anlegen und Verwalten von Aufgaben der Nutzer*innen. Somit l√∂st sie die sogenannte, analoge \textit{To-Do-Liste} ab. Dabei hat die Anwendung (und somit auch die Studienarbeit) keinen Anspruch auf Innovationsdarbierung. Die Begr√ºndung der dieses speziellen Entwicklungsbeispiels liegt darin, dass eine To-Do-Listen-Anwendung ein gro√ües Spektrum von Funktionen abbilden kann. Dieses Spektrum reicht von grundlegenden Funktionen (bspw. dem blo√üen Anlegen von Aufgaben) bis zu komplexeren Inhalten (bspw. automatischen Push-Notifications √ºber unerledigte oder √ºberf√§llige Aufgaben). Diese design- und architekturbedingenden Entscheidungen werden im Folgenden definiert und n√§her beschrieben.

Die Beschreibung der Architektur einer zu entwickelnden Applikation ist eine ma√ügebende Disziplin im Software-Engineering-Prozess. Dieser Prozess geschieht im Regelfall vor Beginn der Implementierung und erm√∂glicht, bezogen auf den Umfang dieser Studienarbeit, die Vergleichbarkeit der Applikation hinsichtlich der relevanten Entwicklungsplattformen. Der Umfang s√§mtlicher Software-Engineering-Prozesse wird grunds√§tzlich in gro√üen Entwicklerteams praktiziert. Diese gehen der Entwicklung meist komplexer und skalierbarer Anwendungen nach. Im Vergleich dazu ist die hier zu entwickelnde Mobilanwendung lediglich Mittel zum Zweck f√ºr die Beantwortung der Forschungsfrage. Das Entwicklungsteam der To-Do-Anwendung besteht aus zwei Personen, welche sich im Rahmen dieser Arbeit autark mit unterschiedlichen Entwicklungsplattformen besch√§ftigen. 

Dies sorgt daf√ºr, dass sich lediglich eine abgespeckte Form des Software-Engineering auf dieses Projekt anwenden l√§sst. Konkret bedeutet dies, dass zum Einen keine spezifischen Aussagen √ºber den Software-Prozess bzw. √ºber das Entwicklungsmodell (Wasserfall-Modell, iteratives Modell, etc.) gemacht werden. Dies w√ºrde sich hinsichtlich des verh√§ltnism√§√üig geringen Entwicklungs- und Wartungsaufwands der App kontraproduktiv auf die Zielorientierung auswirken. Umso wichtiger ist die Definition funktionaler sowie nicht-funktionaler Anforderungen, welche daraufhin n√§her erl√§utert und spezifiziert werden. Auch die Interaktion zwischen Nutzer*in und Anwendung muss f√ºr eine vergleichende Entwicklung definiert werden. Die zeitlichen und komponentenabh√§ngigen Abl√§ufe innerhalb der App geh√∂ren ebenfalls zu den Bestandteilen der Architektur. Letztere beiden Punkte werden im Rahmen des sog. \textit{Systems Modelling} definiert. Dar√ºber hinaus werden auch optische Aspekte und Verhaltensweisen des \ac{ui} abgegrenzt.

\section{Anforderungsdefinition}
Die Funktionalit√§t der Anwendung wird zun√§chst √ºber die Anforderungsdefinition n√§her beschrieben. Diese kann auf allgemeine Funktionsweisen der App (nicht-funktionale Anforderungen), sowie auf spezifische, technische Charakteristika abgegrenzter Bereiche der Anwendung (funktionale Anforderungen). Grunds√§tzlich gilt es, nicht-funktionale Anforderungen im Laufe der Anforderungsdefinition in meist mehrere funktionale Anforderungen zu √ºberf√ºhren, da diese qualifizierbarer sowie quantifizierbarer Natur sind und somit ebenfalls f√ºr eine bessere Vergleichbarkeit der zu entstehenden Anwendungen beitragen k√∂nnten.

\subsection{Nicht-Funktionale Anforderungen}
Die folgenden nicht-funktionalen Anforderungen beziehen sich auf Teile der Anwendung, welche jedoch abstrakter Natur sind, weswegen sie zun√§chst zu nicht-funktionalen Anforderungen gez√§hlt werden m√ºssen. Aufgrund der Formulierung werden diese Anforderungen auch als \textit{Nutzeranforderungen} (engl. \textit{User Requirements}) bezeichnet und stehen den spezifischeren, technisch versierteren \textit{Systemanforderungen} (engl. \textit{System Requirements}) gegen√ºber.
\begin{description}
    \item[Anlegen, Auflisten, Bearbeiten und L√∂schen von Aufgaben] Die Anwendung erm√∂glicht es, Aufgaben hinzuzuf√ºgen. Die hinzugef√ºgten Aufgaben werden aufgelistet. Bei Bedarf soll der Inhalt der Aufgabe nachtr√§glich abge√§ndert werden k√∂nnen. Ebenfalls ist es m√∂glich, die Aufgabe aus der Ansicht innerhalb der Anwendung zu entfernen.
    \item[Aufgaben bestehen nach Neustart der Anwendung bei] Wird die Applikation (gewollt und ungewollt) neu gestartet, bildet sie nach Neustart dieselben Aufgaben und Einstellungen wie zuvor ab.
    \item[Priorisierung der Aufgaben m√∂glich] Bei Bedarf ist es m√∂glich, einer bestimmten Aufgabe einen gesonderten Stellenwert zuzuweisen.
    \item[Benachrichtigungen √ºber nicht-erledigte und √ºberf√§llige Aufgaben] Der*die Nutzer*in wird unabh√§ngig vom Status der Applikation oder des Smartphones (d.h. ge√∂ffnet, im Hintergrund oder geschlossen bzw. gesperrt oder entsperrt) √ºber nicht-erledigte und √ºberf√§llige Aufgaben benachrichtigt.
\end{description}
Neben dieser Art der nicht-funktionalen Anforderungen koexisitieren jene, welche zwar ebenfalls abstrakt und allgemein gehalten sind, jedoch keinen Bedarf resp. keine M√∂glichkeit zur weiteren Spezifizierung an dieser Stelle des Prozesses aufweisen.
\begin{description}
    \item[Bereitstellung der Anwendung f√ºr mehrere Plattformen] Die Anwendung ist nicht nur auf einer Plattform verf√ºgbar, sondern kann auf Ger√§ten unterschiedlicher Betriebssysteme installiert und verwendet werden.
    \item[Aussehen und Verhalten sind deckungsgleich] Unabh√§ngig davon, welche Plattform genutzt wird, ist die Interaktion zwischen dem*der Nutzer*in und der Anwendung ann√§hernd identisch. Davon ausgenommen sind Aspekte, welche auf der entsprechenden Plattform nicht oder nur mit unverh√§ltnism√§√üigem Aufwand erreicht werden k√∂nnen.
    \item[zeiteffizienter Entwicklungsprozess] Um auch einen entwicklungstechnischen Vergleich ziehen zu k√∂nnen, soll die Anwendung in einer dem Projekt angemessenen Zeit vollst√§ndig entwickelt werden k√∂nnen.
\end{description}
Die Problematik nicht-funktionaler Anforderungen im Bezug auf realistisch zu betrachtende Entwicklungsprojekte kann hier interpretiert werden. Vor allem bei eher unerfahrenen Entwicklern (zu welchen sich das Entwicklerteam dieses Projektes zu z√§hlen erlaubt) sind bestimmte Tendenzen unklar. Dazu geh√∂ren bspw. das Bewusstsein √ºber die Realisierbarkeit bestimmter Komponenten sowie die zeitliche Aufwandseinsch√§tzung. Diese St√∂rfaktoren werden im Laufe der Arbeit versucht, entkr√§ftet zu werden und sind in die Evaluation der Forschungsfrage kritisch einzubeziehen.

\subsection{Funktionale Anforderungen}
Nichtsdestotrotz ist die Spezifizierung der in Sektion 3.1.1 eingangs definierten nicht-funtionalen Anforderungen noch ausstehend. Zur Unterst√ºtzung der Lesbarkeit werden diese in Reihenfolge der nicht-funktionalen Anforderungen abgehandelt.

\begin{description}
    \item[Bereitstellung klassischer \acs{crud}-Operationen] Sog. \textit{\ac{crud}}-Operationen greifen auf das Datenmodell der Anwendung zu. Diese erlauben die Manipulation der Daten auf Basis der gew√ºnschten Operation. Diese Operationen sind unabh√§ngig voneinander zu definieren und sinnvoll in den Verwendungsprozess der App einzubauen. Man spricht hier auch von sog. \ac{crud}-\textit{Endpoints}, welche vereinfacht als statische Funktionen beschrieben werden k√∂nnen.
    \item[Listendarstellung] Die Aufgaben sollen grunds√§tzlich in einer sortierten Liste dargestellt werden. Die Liste besteht aus individuellen Elementen, welche jeweils eine Aufgabe darstellen. Jene \ac{crud}-Operationen, welche speziell auf eine bestimmte Aufgabe angewandt werden sollen, finden ihre Aktivierung ebenfalls √ºber ihre entsprechenden Elemente.
    \item[Bereitstellung eines Persistent Services] Bei Ausf√ºhren der zuvor definierten \ac{crud}-Operationen werden die Daten nicht nur in den fl√ºchtigen Arbeitsspeicher des Smartphones geschrieben, sondern zugleich auch auf einen der Applikation zugewiesenen Festspeicher. Diese idealisierte Datenbank gleicht dem Datenmodell f√ºr die \ac{crud}-Operationen und wird somit bei jeder Ausf√ºhrung dieser aktualisiert bzw. beansprucht.
    \item[Definition einer Hierarchie f√ºr Aufgaben] Eine hierarchische Struktur der Daten soll erm√∂glichen, bestimmte Aufgaben seitens der Anwendung anders zu behandeln als andere. Durch das Setzen eines sog. \textit{Flags} k√∂nnen die Aufgaben entsprechend der Hierarchiestruktur bestimmte Zust√§nde √ºbergeben bekommen, konkret eine hervorgehobene optische Darstellung innerhalb der \ac{ui} sowie die Pr√§sentation an Anfang der Liste (Eingriff in die Sortierung der Aufgaben)
\end{description}

Streng genommen sind funktionale Anforderungen sehr granul√§r zu definieren. Da es sich hier jedoch um eine wissenschaftliche Arbeit handelt, und nicht um eine Entwicklerdokumentation, wird auf kleinste Genauigkeiten verzichtet. Viel eher soll die n√§chste Sektion die genaue, weiterhin plattformunabh√§ngige Umsetzung dieser Anforderungen erl√§utern, welche als Ma√ügabe f√ºr die sp√§tere Entwicklung der Applikation dienen soll. \\\

Unabh‰ngig von der Plattform wird zun‰chst ein allgemeines, w‰hrend der individuellen Entwicklungsphase zu spezifizierendes Grundger¸st der Funktionalit‰t definiert. Bei einer To-Do-Applikation besteht dieses grunds‰tzlich aus zwei Komponenten. Die idealisierte \textit{Datenbank} ermˆglicht persistente Speicherung der angelegten To-Do-Eintr‰ge. Diese ist mit verschiedenen \ac{crud}-Funktionen direkt an das \ac{ui} angebunden und ermˆglicht somit die Manipulation der Eintr‰ge.

\section{Speicherung der Daten}
Die Datenbank muss auf eine Weise angelegt werden, dass ihre Daten (d.\ h. To-Do-Eintr‰ge) einem bestimmten Schema folgen. Konkret bedeutet dies folgende Attribute f¸r die \texit{Entit‰t} \texttt{ToDo}:

% TODO Tabellarische Darstellung der Attribute
\begin{itemize}
	\item[\texttt{id}] (alpha-)numerische Zeichenfolge, welche einen Eintrag eindeutig erkennbar macht (String)
	\item[\texttt{text}] anzuzeigender Text, welcher den eigentlichen Eintrag darstellt und beschreibt (String)
	\item[\texttt{done}] Status ¸ber die Erledigung des entsprechenden Eintrages (Bool'scher Wert)
	\item[\texttt{priority}] Status ¸ber die Priorit‰t des entsprechenden Eintrages (Bool'scher Wert)
\end{description}

% TODO Beispiel der idealisierten Datenbankeintr‰ge
Unabh‰ngig von der individuellen Architektur der jeweiligen Apps folgt dieses triviale Schema dem Konzept relationaler Datenbanken und kˆnnte somit in einer einfachen Tabelle dargestellt werden.

Um auf die Datenbank zugreifen zu kˆnnen, muss diese mit entsprechenden Funktionen ausgestattet werden. Neben dem bloﬂen Erstellen von Eintr‰gen, m¸ssen diese abgegriffen (engl. \textit{fetch}) sowie bearbeitet und gelˆscht werden kˆnnen. Die beiden letztgenanten Funktionen haben bei Ausf¸hrung nur Einfluss auf einen durch den*die Nutzer*in ausgew‰hlten Eintrag. Somit m¸ssen diese Funktionen das \textit{Objekt} des entsprechenden Eintrages ¸bergeben bekommen. Weiterhin gliedert sich die Bearbeitung von Eintr‰gen in drei Teilfunktionen auf, n‰mlich dem ƒndern des \texttt{done}- oder \texttt{priority}-Attributes sowie dem ƒndern des beschreibenden Textes des Eintrags.

Da die Ausf¸hrung sowie Umsetzung dieser Operationen mit der \ac{ui} Hand in Hand geht, wird die Definition dieser vorgezogen.

\section{Benutzeroberfl‰che (\ac{ui})}
Die Benutzeroberfl‰che einer solch einfachen To-Do-Anwendung besteht aus lediglich einer Ansicht. Diese Ansicht l‰sst sich hierarchisch definieren. Die oberste Ebene dieser Hierarchie bildet der hier sog. \textit{App-Container}. Anders als in aufw‰ndigeren Applikationen kann dieser hier mit der Ansicht gleichgesetzt werden, da keine weiteren Ansichten existieren. Dieser Container beherbergt eine Listenansicht, welche f¸r die Darstellung und Interaktion mit den bereits vorhandenen Eintr‰gen zust‰ndig ist. F¸r das Erstellen der Eintr‰ge steht ein separates Text(eingabe)feld zur Verf¸gung, sowie ein \textit{Button} zur Best‰tigung der Eingabe.

Die Listenansicht besteht nun aus mehreren Listeneintr‰gen (im Folgenden \texttt{Zellen} genannt). Eine Zelle ist f¸r die Darstellung und Interaktion f¸r genau einen To-Do-Eintrag zust‰ndig. Um dies zu ermˆglichen, besitzt jede Zelle, neben eines Textfeldes zum Anzeigen des To-Do-Textes, weitere Buttons zum Setzen der Priorit‰t und des Status sowie zum Lˆschen des Eintrages. W‰hrend der Button, welcher f¸r das Entfernen des Eintrages verwendet wird (dargestellt durch ein Kreuz, statischer optischer Natur ist (d.\ h., er ‰ndert nach einem Tippen sein Aussehen nicht), untermalen die Buttons der To-Do-Zust‰nde die gew‰hlten Einstellungen durch ihr Aussehen. Der Button f¸r Priorisierung, welcher durch ein Sternsymbol dargestellt wird, ist bei aktiver Priorisierung gef¸llt. Ist dies nicht der Fall, so ist lediglich der Umriss des Symbols zu erkennen. Gleiches gilt f¸r den Button, welcher anzeigt, ob der Eintrag bereits erledigt ist, dargestellt durch ein H‰kchen inmitten eines Kreises.

Die beschriebenen, visuellen Eigenschaften lassen sich nun in einem sog. \textit{Wireframe} zusammenfassen, welches gleichzeitig die optische Grundlage der Entwicklung darstellen wird. Dies ist vor allem aufgrund der unterschiedlichen Entwicklungsplattformen von Relevanz, da das Einhalten bestimmter Standards der entsprechenden Plattformen daf¸r sorgen kˆnnte, dass der letztendliche Vergleich beider Applikationen hohe Differenzen aufweist.

\begin{figure}[h!]
        \includegraphics[scale=0.5]{img/wireframe.png}
        \centering
        \caption{Wireframe}
        \label{fig:wireframe}
\end{figure}

Eine Besonderheit in der Darstellung l‰sst sich innerhalb der priorisierten Elemente finden. Um diese weiter hervorzuheben, werden diese an den Anfang der Liste gesetzt. Es entstehen somit zwei Teillisten, welche sich jedoch in derselben Listenansicht befinden. Wird nun ein zuvor nicht-priorisierter Eintr‰g priorisiert, so wechselt dieser seine Position ans Ende der Liste mit den bereits priorisierten Eintr‰gen (bzw. wird oberhalb der ersten nicht-priorisierten Elements platziert). Alle Eintr‰ge zwischen der alten und der neuen Position des gerade betrachteten Eintrags werden um eine Listenposition nach unten verschoben. Bei Entfernen der Priorisierung wird das entsprechende Element nun nicht an seine urspr¸ngliche Position vor der Priorisierung, sondern an den Anfang der nicht-priorisierten Liste verschoben. Entfernt man also bspw. die Priorisierung der letzten Elements in der priorisierten Liste, ‰ndert sich die Reihenfolge nicht. Dieses Verhalten kann vereinfacht in der untenstehenden Abbildung dargestellt werden.

% TODO Verschˆnerung und Erweiterung der Grafik
\begin{figure}[h!]
        \includegraphics[width=\linewidth]{img/sketch_insert.png}
        \centering
        \caption{Verhalten beim Einf√ºgen}
        \label{fig:inserttodo}
\end{figure}

Grunds‰tzlich werden alle Eintr‰ge in der Reihenfolge dargestellt, wie sie angelegt wurden, mit den eben beschriebenen Ausnahmen.


\subsection{Farbliche Darstellung}
Um ebenfalls f¸r farbliche Konsistenz zu sorgen, werden die beschriebenen Elemente auf Basis der folgenden Tabelle in ihrem Erscheinungsbild konfiguriert:

\begin{table}[h!]
  \centering
    \begin{tabular}{ |c|c|c|}
     \hline
    \textbf{Bezeichnung} & \textbf{HEX-Code} & \textbf{Beispiel}\\
    \hline
    
    
    \hline
    \multicolumn{3}{|c|}{\textbf{Allgemeines}}\\
     \hline
    Hintergrund & \texttt{\#F2F2F2} &\cellcolor[HTML]{F2F2F2}\\
        \hline
         Schriftfarbe & \texttt{\#8C8C8C} &\cellcolor[HTML]{8C8C8C}\\
     \hline
     
     
      \hline
    \multicolumn{3}{|c|}{\textbf{Bedienelemente}}\\
     \hline
      Hintergrund f√ºr inaktive Bedienelemente & \texttt{\#CECECE} &\cellcolor[HTML]{CECECE}\\
     \hline
    Checkbox (checked) Hintergrund & \texttt{\#1A66FF} &\cellcolor[HTML]{1A66FF}\\
    \hline
     Schriftfarbe der Checkbox (checked) & \texttt{\#FFFFFF} &\cellcolor[HTML]{FFFFFF}\\
     \hline
    \end{tabular}
  \caption{Farbtabelle} \label{tab:farbtabelle}
\end{table}


% Spaﬂ mit Activity-Diagrammen!
\section{Nutzungszyklus}
Der*die Nutzer*in ˆffnet die Anwendung. Beim Laden der Ansicht wird eine Datenbank-Funktion ausgef¸hrt, um bereits existierende Eintr‰ge zu laden und ihre entsprechenden Beschreibungen samt weiteren Attributen in die einzelnen Zellen der Listenansicht zu laden. 

Der*die Nutzer*in mˆchte einen neuen To-Do-Eintrag erstellen. Daf¸r wird ein beschreibender Text in das Texteingabefeld am unteren Rand der Ansicht geschrieben. Um einen neuen Eintrag zu erstellen, wird ein beschreibender Text in das Texteingabefeld am unteren Rand der Ansicht geschrieben. Mit der Best‰tigung ¸ber den \texttt{+}-Button wird ein neuer Eintrag in die Datenbank aufgefordert, wobei das \texttt{text}-Attribut mit dem zuvor gew‰hlten Text aus dem Eingabefeld gef¸llt wird. Die Zeichenfolge der \texttt{id} wird automatisch und zufallsbasiert generiert, \texttt{done} sowie \texttt{priority} standardm‰ﬂig auf \texttt{false} gesetzt. Der neue Eintrag wird unter den bereits vorhandenen Eintr‰gen angef¸gt. Stern- sowie H‰kchensymbol werden lediglich ¸ber ihre Kontur kenntlich gemacht.

Der*die Nutzer*in mˆchte den Test eines Eintrages ‰ndern. Durch direktes Tippen auf den dargestellten Text in einer Zelle wird dies ermˆglicht. Es erscheint ein Cursor, welcher ebenfalls Tastatur- und Ber¸hrgesten innerhalb dieses Feldes ermˆglicht. Nach best‰tigter ƒnderung ¸ber das Verlassen des Textfeldes (d.\ h. dem Tippen auf eine andere Stelle innerhalb der Ansicht) wird erneut eine Datenbank-Funktion ausgef¸hrt. Diese bekommt das \texttt{ToDo}-Objekt ¸bergeben und ersetzt den bestehenden Inhalt des \texttt{text}-Attributes mit dem nun ge‰nderten.

Der*die Nutzer*in mˆchte den zuvor erstellten Eintrag priorisieren. Tippt diese*r auf das Stern-Symbol, wird dieses mit der zuvor definierten Farbe gef¸llt. Gleichzeitig bewegt sich das priorisierte Element an das Ende der Teilliste mit priorisierten Eintr‰gen. Eine Datenbank-Funktion wird aufgerufen, welche den \texttt{priority}-Wert des ¸bergebenen Objekts von \texttt{false} auf \texttt{true} setzt.

Der*die Nutzer*in mˆchte den zuvor priorisierten Eintrag als abgeschlossen markieren. Tippt diese*r auf das H‰kchen-Symbol wird dieses mit der zuvor definierten Farbe gef¸llt. Eine Datenbank-Funktion wird aufgerufen, welche den \texttt{done}-Wert des ¸bergebenen Objekts von \texttt{false} auf \texttt{true} setzt.

Der*die Nutzer*in mˆchte den zuvor als abgeschlossenen Eintrag aus der Liste der priorisierten Eintr‰ge entfernen. Tippt diese*r auf das Stern-Symbol, wird dessen F¸llung entfernt. Gleichzeitig bewegt sich das Element an den Anfang der Teilliste mit nicht-priorisierten Eintr‰gen. Die zuvor ausgef¸hrte Datenbank-Funktion wird erneut aufgerufen, welche den \texttt{priority}-Wert des ¸bergebenen Objekts von \texttt{true} nun wieder auf \texttt{false} setzt.

Der*die Nutzer*in mˆchte den Eintrag abschlieﬂend entfernen. Tipps diese*r auf das Kreuz-Symbol, wird der Eintrag aus der Liste entfernt. Die Elemente unterhalb des gelˆschten Eintrags verschieben sich um jeweils eine Position nach oben. Eine Datenbank-Funktion wird aufgerufen, welche das ¸bergebene Objekt des Eintrages aus der Datenbank entfernt.

%===================================================================================
%  DEPRECATED / DISCUSSION REQ
%===================================================================================

%\section{Komponenten}
%\begin{description}
%    \item \textbf{App Container}\\
%    Das unterste UI-Element der Anwendung wird im Folgenden als App Container bezeichnet, da es aufgrund der verschiedenen Technologien keine einheitliche Bezeichnung daf√ºr gibt. Der App Container ist bei der PWA das \texttt{body} Element des HTML und bei der nativen iOS App ein \texttt{View} Element.
%    
%    \textbf{Besonderes:} Ist der Inhalt des App Containers gr√∂√üer, als der Bildschirm, wird in vertikale Richtung gescrollt. Es gibt kein horizontales Scrolling, stattdessen m√ºssen sich alle anderen Elemente automatisch anpassen.
%
%    \item \textbf{Todoliste}\\
%    Der Kern der Anwendung ist eine Liste, die einzelne Todos enth√§lt. Neue Todos werden stets unten an die Liste angef√ºgt.
%    
%    \textbf{Besonderes:} Es gibt genau eine Todoliste. Sie kann nicht gel√∂scht werden und enth√§lt mindestens ein (leeres) Todo.
%    
%    \item \textbf{Todo (Listeneintrag)}\\
%    Ein Todo ist ein Listenelement der Todoliste. Dieses besteht aus einem editierbaren Textfeld. Seitlich des Textfelds befinden sich Buttons zum Entfernen des Eintrags und zum Markieren des Eintrags als "wichtig".
%    
%    Das Todo hat links neben dem Eingabefeld eine Checkbox. Bis zum "check" durch den Nutzer ist die Checkbox nicht markiert.
%    
%    \textbf{Besonderes:} Wenn der Inhalt eines bestehenden Todos gel√∂scht wird, bleibt es bestehen und wird nicht automatisch entfernt.
%    
%    \item \textbf{Eingabem√∂glichkeit}\\
%    Damit der Nutzer neue Todos eintragen kann, wird ein Eingabefeld ben√∂tigt. Das Eingabefeld ist idealerweise in die Todoliste integriert. F√ºr den Nutzer soll stets ein Eingabefeld unter der Todoliste sichtbar sein.
%    Da bereits die Todoliste aus einzelnen Eingabefeldern besteht, muss diese w√§hrend der Eingabe eines neuen Elements nur um ein neues leeres Listenelement erweitert werden.
%    
%    \textbf{Besonderes:} Es werden keine leeren Todos eingef√ºgt. Ein Todo muss mindestens ein Zeichen enthalten.
%\end{description}
%
%\section{Designentscheidungen PWA}
%Seit 2014 bis heute ist JavaScript die h√§ufigste Sprache auf GitHub. Das st√§rker typisierte TypeScript geh√∂rt zu den am schnellsten wachsenden Sprachen \cite{OctoverseGitHubStatistics}. Um diese Arbeit zukunftsgewandt zu evaluieren, werden deshalb das bereits beschriebene Angular-Framework verwendet, dass TypeScript (transpilierter zu JavaScript) und die Node.js Laufzeitumgebung nutzt. Nicht zuletzt ist auch der Gro√üe Beitrag von Google (als Mobilger√§tehersteller und Betriebssystementwickler von Android) zum Angular-Projekt ein Grund, die PWA in Form einer Angular Anwendung zu realisieren.

%\subsection{Gr√∂√üen}
%\begin{figure}[h]
%        \includegraphics[scale=0.5]{img/Wireframe_dimensions.jpg}
%        \centering
%        \caption{Gr√∂√üen}
%        \label{fig:dimensions}
%\end{figure}